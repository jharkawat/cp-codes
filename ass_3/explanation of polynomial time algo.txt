The running time of Squirrel’s algorithm is linear in the number of squares n = m 2 ; initialize() takes θ(n) time, initializeTable() takes constant time, and Tour() requires n iterations through the while loop, each of which requires a constant number of steps. Algorithm actually runs in θ(nlogn), since the numbers that denote the order in which squares are visited actually contain θ(logn) bits. If instead we had chosen to label the squares by the move-type we use to get to the next square, then we only need to deal with numbers from 1 to 8, which require just 3 bits. For the purposes of running time, we can assume that we are using this implementation and that the algorithm runs in linear time.
Squirrel’s algorithm is not the first linear time algorithm for finding knight’s tours [2, 3, 4, 7]. All of the other algorithms employ a divide and conquer strategy, subdividing the board into several smaller boards and combining tours on these boards into a full tour, using solutions of several small boards as base cases. While these algorithms maintain the same asymtptotic level of efficiency as Squirrel’s algorithm and are perhaps more elegant, Squirrel’s algorithm is simpler than all of them in the following sense. Technically all of the divide and conquer algorithms as well as Squirrel’s algorithm require θ(n) space – as we need a way to access all n squares. In addition to the space needed to store the squares Squirrel’s algorithm requires just constant space – a few integers and the table of move-orderings and switching squares. The divide and conquer algorithms, on the other hand, require an implicit stack for the recursive calls and use θ(logn) additional space. Hence if we ignored the space needed to store the squares, Squirrel’s algorithm would use much less memory. If we consider the case of a human tracing out the algorithm on an actual chessboard, we can treat the space required by the board as a given for all the algorithms. In this case, Squirrel’s algorithm would require asymptotically less space than the other algorithms – meaning the human would need access to less information to complete the tour. Thus Squirrel’s algorithm is better suited for actual human implementation than the divide and conquer methods.
